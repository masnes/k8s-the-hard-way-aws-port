resource "local_file" "kubernetes_public_address" {
  depends_on = [
    aws_eip.k8s_external,
    data.aws_eip.k8s_internal  # Avoid timing error requiring terraform refresh
  ]
  filename             = "${path.module}/../../ansible/group_vars/all/kubernetes_public_address.yml"
  file_permission      = "0644"
  directory_permission = "0755"
  content              = <<-EOT
# Autogenerated by Terraform
kubernetes_address_public: "${aws_eip.k8s_external.public_ip}"
kubernetes_address_private: "${data.aws_eip.k8s_internal.private_ip}"
cluster_cidr: "${var.cluster_cidr}"
EOT
}

resource "local_file" "ansible_hosts" {

  depends_on = [
    aws_instance.controller[0],
    aws_instance.controller[1],
    aws_instance.controller[2],
    aws_instance.worker[0],
    aws_instance.worker[1],
    aws_instance.worker[2],
  ]

  filename             = "${path.module}/../../ansible/hosts"
  file_permission      = "0644"
  directory_permission = "0755"
  content              = <<-EOT
# Autogenerated by Terraform
[workers]
%{for index, worker in aws_instance.worker.*~}
worker-${index} ansible_host=${worker.public_ip} ansible_user=ubuntu public_ip=${worker.public_ip} internal_ip=${worker.private_ip} pod_cidr="${worker.tags["pod_cidr"]}"
%{endfor~}

[controllers]
%{for index, controller in aws_instance.controller.*~}
controller-${index} ansible_host=${controller.public_ip} ansible_user=ubuntu public_ip=${controller.public_ip} internal_ip=${controller.private_ip}
%{endfor~}
EOT

}
